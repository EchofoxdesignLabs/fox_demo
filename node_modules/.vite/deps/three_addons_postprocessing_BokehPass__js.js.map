{
  "version": 3,
  "sources": ["../../three/examples/jsm/shaders/BokehShader.js", "../../three/examples/jsm/postprocessing/BokehPass.js"],
  "sourcesContent": ["/**\r\n * @module BokehShader\r\n * @three_import import { BokehShader } from 'three/addons/shaders/BokehShader.js';\r\n */\r\n\r\n/**\r\n * Depth-of-field shader with bokeh ported from\r\n * [GLSL shader by Martins Upitis]{@link http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html}.\r\n *\r\n * @constant\r\n * @type {ShaderMaterial~Shader}\r\n */\r\nconst BokehShader = {\r\n\r\n\tname: 'BokehShader',\r\n\r\n\tdefines: {\r\n\t\t'DEPTH_PACKING': 1,\r\n\t\t'PERSPECTIVE_CAMERA': 1,\r\n\t},\r\n\r\n\tuniforms: {\r\n\r\n\t\t'tColor': { value: null },\r\n\t\t'tDepth': { value: null },\r\n\t\t'focus': { value: 1.0 },\r\n\t\t'aspect': { value: 1.0 },\r\n\t\t'aperture': { value: 0.025 },\r\n\t\t'maxblur': { value: 0.01 },\r\n\t\t'nearClip': { value: 1.0 },\r\n\t\t'farClip': { value: 1000.0 },\r\n\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvUv = uv;\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\r\n\t\t#include <common>\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tuniform sampler2D tColor;\r\n\t\tuniform sampler2D tDepth;\r\n\r\n\t\tuniform float maxblur; // max blur amount\r\n\t\tuniform float aperture; // aperture - bigger values for shallower depth of field\r\n\r\n\t\tuniform float nearClip;\r\n\t\tuniform float farClip;\r\n\r\n\t\tuniform float focus;\r\n\t\tuniform float aspect;\r\n\r\n\t\t#include <packing>\r\n\r\n\t\tfloat getDepth( const in vec2 screenPosition ) {\r\n\t\t\t#if DEPTH_PACKING == 1\r\n\t\t\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\r\n\t\t\t#else\r\n\t\t\treturn texture2D( tDepth, screenPosition ).x;\r\n\t\t\t#endif\r\n\t\t}\r\n\r\n\t\tfloat getViewZ( const in float depth ) {\r\n\t\t\t#if PERSPECTIVE_CAMERA == 1\r\n\t\t\treturn perspectiveDepthToViewZ( depth, nearClip, farClip );\r\n\t\t\t#else\r\n\t\t\treturn orthographicDepthToViewZ( depth, nearClip, farClip );\r\n\t\t\t#endif\r\n\t\t}\r\n\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvec2 aspectcorrect = vec2( 1.0, aspect );\r\n\r\n\t\t\tfloat viewZ = getViewZ( getDepth( vUv ) );\r\n\r\n\t\t\tfloat factor = ( focus + viewZ ); // viewZ is <= 0, so this is a difference equation\r\n\r\n\t\t\tvec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );\r\n\r\n\t\t\tvec2 dofblur9 = dofblur * 0.9;\r\n\t\t\tvec2 dofblur7 = dofblur * 0.7;\r\n\t\t\tvec2 dofblur4 = dofblur * 0.4;\r\n\r\n\t\t\tvec4 col = vec4( 0.0 );\r\n\r\n\t\t\tcol += texture2D( tColor, vUv.xy );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );\r\n\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\r\n\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );\r\n\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\r\n\t\t\tcol += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );\r\n\r\n\t\t\tgl_FragColor = col / 41.0;\r\n\t\t\tgl_FragColor.a = 1.0;\r\n\r\n\t\t}`\r\n\r\n};\r\n\r\nexport { BokehShader };\r\n", "import {\r\n\tColor,\r\n\tHalfFloatType,\r\n\tMeshDepthMaterial,\r\n\tNearestFilter,\r\n\tNoBlending,\r\n\tRGBADepthPacking,\r\n\tShaderMaterial,\r\n\tUniformsUtils,\r\n\tWebGLRenderTarget\r\n} from 'three';\r\nimport { Pass, FullScreenQuad } from './Pass.js';\r\nimport { BokehShader } from '../shaders/BokehShader.js';\r\n\r\n/**\r\n * Pass for creating depth of field (DOF) effect.\r\n *\r\n * ```js\r\n * const bokehPass = new BokehPass( scene, camera, {\r\n * \tfocus: 500\r\n * \taperture: 5,\r\n * \tmaxblur: 0.01\r\n * } );\r\n * composer.addPass( bokehPass );\r\n * ```\r\n *\r\n * @augments Pass\r\n * @three_import import { BokehPass } from 'three/addons/postprocessing/BokehPass.js';\r\n */\r\nclass BokehPass extends Pass {\r\n\r\n\t/**\r\n\t * Constructs a new Bokeh pass.\r\n\t *\r\n\t * @param {Scene} scene - The scene to render the DOF for.\r\n\t * @param {Camera} camera - The camera.\r\n\t * @param {BokehPass~Options} params - The pass options.\r\n\t */\r\n\tconstructor( scene, camera, params ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\t/**\r\n\t\t * The scene to render the DOF for.\r\n\t\t *\r\n\t\t * @type {Scene}\r\n\t\t */\r\n\t\tthis.scene = scene;\r\n\r\n\t\t/**\r\n\t\t * The camera.\r\n\t\t *\r\n\t\t * @type {Camera}\r\n\t\t */\r\n\t\tthis.camera = camera;\r\n\r\n\t\tconst focus = ( params.focus !== undefined ) ? params.focus : 1.0;\r\n\t\tconst aperture = ( params.aperture !== undefined ) ? params.aperture : 0.025;\r\n\t\tconst maxblur = ( params.maxblur !== undefined ) ? params.maxblur : 1.0;\r\n\r\n\t\t// render targets\r\n\r\n\t\tthis._renderTargetDepth = new WebGLRenderTarget( 1, 1, { // will be resized later\r\n\t\t\tminFilter: NearestFilter,\r\n\t\t\tmagFilter: NearestFilter,\r\n\t\t\ttype: HalfFloatType\r\n\t\t} );\r\n\r\n\t\tthis._renderTargetDepth.texture.name = 'BokehPass.depth';\r\n\r\n\t\t// depth material\r\n\r\n\t\tthis._materialDepth = new MeshDepthMaterial();\r\n\t\tthis._materialDepth.depthPacking = RGBADepthPacking;\r\n\t\tthis._materialDepth.blending = NoBlending;\r\n\r\n\t\t// bokeh material\r\n\r\n\t\tconst bokehUniforms = UniformsUtils.clone( BokehShader.uniforms );\r\n\r\n\t\tbokehUniforms[ 'tDepth' ].value = this._renderTargetDepth.texture;\r\n\r\n\t\tbokehUniforms[ 'focus' ].value = focus;\r\n\t\tbokehUniforms[ 'aspect' ].value = camera.aspect;\r\n\t\tbokehUniforms[ 'aperture' ].value = aperture;\r\n\t\tbokehUniforms[ 'maxblur' ].value = maxblur;\r\n\t\tbokehUniforms[ 'nearClip' ].value = camera.near;\r\n\t\tbokehUniforms[ 'farClip' ].value = camera.far;\r\n\r\n\t\t/**\r\n\t\t * The pass bokeh material.\r\n\t\t *\r\n\t\t * @type {ShaderMaterial}\r\n\t\t */\r\n\t\tthis.materialBokeh = new ShaderMaterial( {\r\n\t\t\tdefines: Object.assign( {}, BokehShader.defines ),\r\n\t\t\tuniforms: bokehUniforms,\r\n\t\t\tvertexShader: BokehShader.vertexShader,\r\n\t\t\tfragmentShader: BokehShader.fragmentShader\r\n\t\t} );\r\n\r\n\t\t/**\r\n\t\t * The pass uniforms.  Use this object if you want to update the\r\n\t\t * `focus`, `aperture` or `maxblur` values at runtime.\r\n\t\t *\r\n\t\t * ```js\r\n\t\t * pass.uniforms.focus.value = focus;\r\n\t\t * pass.uniforms.aperture.value = aperture;\r\n\t\t * pass.uniforms.maxblur.value = maxblur;\r\n\t\t * ```\r\n\t\t *\r\n\t\t * @type {Object}\r\n\t\t */\r\n\t\tthis.uniforms = bokehUniforms;\r\n\r\n\t\t// internals\r\n\r\n\t\tthis._fsQuad = new FullScreenQuad( this.materialBokeh );\r\n\r\n\t\tthis._oldClearColor = new Color();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Performs the Bokeh pass.\r\n\t *\r\n\t * @param {WebGLRenderer} renderer - The renderer.\r\n\t * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering\r\n\t * destination for the pass.\r\n\t * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the\r\n\t * previous pass from this buffer.\r\n\t * @param {number} deltaTime - The delta time in seconds.\r\n\t * @param {boolean} maskActive - Whether masking is active or not.\r\n\t */\r\n\trender( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive*/ ) {\r\n\r\n\t\t// Render depth into texture\r\n\r\n\t\tthis.scene.overrideMaterial = this._materialDepth;\r\n\r\n\t\trenderer.getClearColor( this._oldClearColor );\r\n\t\tconst oldClearAlpha = renderer.getClearAlpha();\r\n\t\tconst oldAutoClear = renderer.autoClear;\r\n\t\trenderer.autoClear = false;\r\n\r\n\t\trenderer.setClearColor( 0xffffff );\r\n\t\trenderer.setClearAlpha( 1.0 );\r\n\t\trenderer.setRenderTarget( this._renderTargetDepth );\r\n\t\trenderer.clear();\r\n\t\trenderer.render( this.scene, this.camera );\r\n\r\n\t\t// Render bokeh composite\r\n\r\n\t\tthis.uniforms[ 'tColor' ].value = readBuffer.texture;\r\n\t\tthis.uniforms[ 'nearClip' ].value = this.camera.near;\r\n\t\tthis.uniforms[ 'farClip' ].value = this.camera.far;\r\n\r\n\t\tif ( this.renderToScreen ) {\r\n\r\n\t\t\trenderer.setRenderTarget( null );\r\n\t\t\tthis._fsQuad.render( renderer );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.setRenderTarget( writeBuffer );\r\n\t\t\trenderer.clear();\r\n\t\t\tthis._fsQuad.render( renderer );\r\n\r\n\t\t}\r\n\r\n\t\tthis.scene.overrideMaterial = null;\r\n\t\trenderer.setClearColor( this._oldClearColor );\r\n\t\trenderer.setClearAlpha( oldClearAlpha );\r\n\t\trenderer.autoClear = oldAutoClear;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the size of the pass.\r\n\t *\r\n\t * @param {number} width - The width to set.\r\n\t * @param {number} height - The height to set.\r\n\t */\r\n\tsetSize( width, height ) {\r\n\r\n\t\tthis.materialBokeh.uniforms[ 'aspect' ].value = width / height;\r\n\r\n\t\tthis._renderTargetDepth.setSize( width, height );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Frees the GPU-related resources allocated by this instance. Call this\r\n\t * method whenever the pass is no longer used in your app.\r\n\t */\r\n\tdispose() {\r\n\r\n\t\tthis._renderTargetDepth.dispose();\r\n\r\n\t\tthis._materialDepth.dispose();\r\n\t\tthis.materialBokeh.dispose();\r\n\r\n\t\tthis._fsQuad.dispose();\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Constructor options of `BokehPass`.\r\n *\r\n * @typedef {Object} BokehPass~Options\r\n * @property {number} [focus=1] - Defines the effect's focus which is the distance along the camera's look direction in world units.\r\n * @property {number} [aperture=0.025] - Defines the effect's aperture.\r\n * @property {number} [maxblur=1] - Defines the effect's maximum blur.\r\n **/\r\n\r\nexport { BokehPass };\r\n"],
  "mappings": "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",
  "names": []
}
